{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://mfecane.github.io/./src/shaders/nebula.frag","webpack://mfecane.github.io/./src/shaders/nebula.vert","webpack://mfecane.github.io/webpack/bootstrap","webpack://mfecane.github.io/webpack/runtime/compat get default export","webpack://mfecane.github.io/webpack/runtime/define property getters","webpack://mfecane.github.io/webpack/runtime/hasOwnProperty shorthand","webpack://mfecane.github.io/./src/ts/webgl/shader.ts","webpack://mfecane.github.io/./src/ts/components/orbit-control.ts","webpack://mfecane.github.io/./src/ts/components/nebula.ts","webpack://mfecane.github.io/./src/ts/index.ts"],"sourcesContent":["module.exports = \"#version 300 es\\n\\nprecision highp float;\\n\\nout vec4 FragColor;\\nin vec2 uv;\\n\\nuniform float u_mouseX;\\nuniform float u_mouseY;\\n\\n#define ROTATION\\n//#define MOUSE_CAMERA_CONTROL\\n\\n#define DITHERING\\n#define BACKGROUND\\n\\n//#define TONEMAPPING\\n\\n//-------------------\\n#define pi 3.14159265\\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\\n\\n// iq's noise\\nfloat noise( in vec3 x )\\n{\\n  vec3 p = floor(x);\\n  vec3 f = fract(x);\\n\\tf = f * f * (3.0 - 2.0 * f);\\n\\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\\n\\treturn 1.0 - 0.82 * mix(0.0, 0.0, f.z);\\n}\\n\\nfloat rand(vec2 co)\\n{\\n\\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\n//=====================================\\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\\n//--------------------------------------------------------------\\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\\n// It should work the same on all computers since it's not based on a hash function like some other noises.\\n// It can be much faster than other noise functions if you're ok with some repetition.\\nconst float nudge = 0.739513;\\t// size of perpendicular vector\\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\\t// pythagorean theorem on that perpendicular to maintain scale\\nfloat SpiralNoiseC(vec3 p)\\n{\\n  float n = 0.0;\\t// noise amount\\n  float iter = 1.0;\\n  for (int i = 0; i < 8; i++)\\n  {\\n    // add sin and cos scaled inverse with the frequency\\n    n += -abs(sin(p.y * iter) + cos(p.x * iter)) / iter;\\t// abs for a ridged look\\n    // rotate by adding perpendicular and scaling down\\n    p.xy += vec2(p.y, -p.x) * nudge;\\n    p.xy *= normalizer;\\n    // rotate on other axis\\n    p.xz += vec2(p.z, -p.x) * nudge;\\n    p.xz *= normalizer;\\n    // increase the frequency\\n    iter *= 1.733733;\\n  }\\n  return n;\\n}\\n\\nfloat SpiralNoise3D(vec3 p)\\n{\\n  float n = 0.0;\\n  float iter = 1.0;\\n  for (int i = 0; i < 5; i++)\\n  {\\n    n += (sin(p.y * iter) + cos(p.x * iter)) / iter;\\n    p.xz += vec2(p.z, -p.x) * nudge;\\n    p.xz *= normalizer;\\n    iter *= 1.33733;\\n  }\\n  return n;\\n}\\n\\nfloat NebulaNoise(vec3 p)\\n{\\n  float final = p.y + 4.5;\\n  final -= SpiralNoiseC(p.xyz);   // mid-range noise\\n  final += SpiralNoiseC(p.zxy * 0.5123 + 100.0) * 4.0;   // large scale features\\n  final -= SpiralNoise3D(p);   // more large scale features, but 3d\\n\\n  return final;\\n}\\n\\nfloat map(vec3 p)\\n{\\n  float NebNoise = abs(NebulaNoise(p / 0.5) * 0.5);\\n  return NebNoise + 0.03;\\n}\\n//--------------------------------------------------------------\\n\\n// assign color to the media\\nvec3 computeColor( float density, float radius )\\n{\\n\\t// color based on density alone, gives impression of occlusion within\\n\\t// the media\\n\\tvec3 result = mix(vec3(1.0, 0.9, 0.8), vec3(0.4, 0.15, 0.1), density);\\n\\n\\t// color added to the media\\n\\tvec3 colCenter = 7.0 * vec3(0.8, 1.0, 1.0);\\n\\tvec3 colEdge = 1.5 * vec3(0.48, 0.53, 0.5);\\n\\tresult *= mix(colCenter, colEdge, min((radius + 0.05) / 0.9, 1.15));\\n\\n\\treturn result;\\n}\\n\\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\\n{\\n\\tfloat b = dot(dir, org);\\n\\tfloat c = dot(org, org) - 8.;\\n\\tfloat delta = b*b - c;\\n\\tif( delta < 0.0)\\n\\t\\treturn false;\\n\\tfloat deltasqrt = sqrt(delta);\\n\\tnear = -b - deltasqrt;\\n\\tfar = -b + deltasqrt;\\n\\treturn far > 0.0;\\n}\\n\\n// Applies the filmic curve from John Hable's presentation\\n// More details at : http://filmicgames.com/archives/75\\nvec3 ToneMapFilmicALU(vec3 _color)\\n{\\n\\t_color = max(vec3(0), _color - vec3(0.004));\\n\\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\\n\\treturn _color;\\n}\\n\\nvoid main()\\n{\\n  vec3 debugColor;\\n  float seed = 1.3;\\n  //   const float KEY_1 = 49.5/256.0;\\n\\t// const float KEY_2 = 50.5/256.0;\\n\\t// const float KEY_3 = 51.5/256.0;\\n  float key = 0.0;\\n  // key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\\n  // key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\\n  // key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\\n\\n\\t// ro: ray origin\\n\\t// rd: direction of the ray\\n\\t// vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\\n\\tvec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0));\\n\\tvec3 rayOrigin = vec3(0.0, 0.0, -3.0);\\n\\n  //   #ifdef MOUSE_CAMERA_CONTROL\\n  const float mouseFactor = 0.002;\\n  R(rayDirection.yz, -u_mouseY * mouseFactor * pi * 2.0);\\n  R(rayDirection.xz, u_mouseX * mouseFactor * pi * 2.0);\\n  R(rayOrigin.yz, -u_mouseY * mouseFactor * pi * 2.0);\\n  R(rayOrigin.xz, u_mouseX * mouseFactor * pi * 2.0);\\n  //   #else\\n  //   R(rayDirection.yz, -pi*3.93);\\n  //   R(rayDirection.xz, pi*3.2);\\n  //   R(rayOrigin.yz, -pi*3.93);\\n  //  \\tR(rayOrigin.xz, pi*3.2);\\n  //   #endif\\n\\n  //   #ifdef DITHERING\\n\\t// vec2 dpos = ( fragCoord.xy / iResolution.xy );\\n\\t// vec2 seed = dpos + fract(iTime);\\n\\t// #endif\\n\\n\\t// ld, totalDensity: local, total density\\n\\t// w: weighting factor\\n\\tfloat localDensity = 0.0, totalDensity = 0.0, w = 0.0;\\n\\n\\t// t: length of the ray\\n\\t// d: distance function\\n\\tfloat d = 1.0, t = 0.0;\\n\\n  const float h = 0.1;\\n\\n\\tvec4 sum = vec4(0.0);\\n\\n  float min_dist = 0.0, max_dist = 0.0;\\n\\n\\n  // march ray to the sphere\\n  if (RaySphereIntersect(rayOrigin, rayDirection, min_dist, max_dist))\\n  {\\n\\t  t = min_dist * step(t, min_dist);\\n\\n    // raymarch loop\\n    for (int i = 0; i < 56; i++)\\n    {\\n      vec3 pos = rayOrigin + t * rayDirection;\\n\\n      if (totalDensity > 0.9 || d < 0.1 * t || t > 10.0 || sum.a > 0.99 || t > max_dist) break;\\n\\n      // evaluate distance function\\n      float d = map(pos);\\n\\n  // change this string to control density\\n      d = max(d, 0.07);\\n\\n      // point light calculations\\n      vec3 ldst = vec3(0.0)-pos;\\n      float lDist = max(length(ldst), 0.001);\\n\\n      // star in center\\n      vec3 lightColor=vec3(1.0, 0.5, 0.25);\\n      sum.rgb += (lightColor / (lDist * lDist) / 30.0); // star itself and bloom around the light\\n\\n      if (d < h)\\n      {\\n        // compute local density\\n        localDensity = h - d;\\n\\n              // compute weighting factor\\n        w = (1.0 - totalDensity) * localDensity;\\n\\n        // accumulate density\\n        totalDensity += w + 1./200.;\\n\\n        vec4 col = vec4( computeColor(totalDensity, lDist), totalDensity );\\n\\n        // uniform scale density\\n        col.a *= 0.185;\\n        // colour by alpha\\n        col.rgb *= col.a;\\n        // alpha blend in contribution\\n        sum = sum + col*(1.0 - sum.a);\\n\\n      }\\n\\n      totalDensity += 1./70.;\\n\\n      // enforce minimum stepsize\\n      d = max(d, 0.04);\\n\\n      // #ifdef DITHERING\\n      // // add in noise to reduce banding and create fuzz\\n      // d=abs(d)*(.8+0.2*rand(seed*vec2(i)));\\n      // #endif\\n\\n      // trying to optimize step size near the camera and near the light source\\n      t += max(d * 0.1 * max(min(length(ldst), length(rayOrigin)), 1.0), 0.02);\\n    }\\n    debugColor = vec3(sum);\\n\\n    // simple scattering\\n\\t  sum *= 1.0 / exp( localDensity * 0.2 ) * 0.6;\\n   \\tsum = clamp( sum, 0.0, 1.0 );\\n    sum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\\n\\t}\\n\\n    // #ifdef BACKGROUND\\n    // // stars background\\n    // if (totalDensity<.8)\\n    // {\\n    //     vec3 stars = vec3(noise(rayDirection*500.0)*0.5+0.5);\\n    //     vec3 starbg = vec3(0.0);\\n    //     starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rayDirection)+0.75,0.0,1.0));\\n    //     starbg = clamp(starbg, 0.0, 1.0);\\n    //     sum.xyz += starbg;\\n    // }\\n\\n\\t// #endif\\n    // FragColor = vec4(sum.xyz, 1.0);\\n  FragColor = vec4(vec3(debugColor), 1.0);\\n\\n  //   #ifdef TONEMAPPING\\n  //   fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\\n\\t// #else\\n  //   fragColor = vec4(sum.xyz,1.0);\\n\\t// #endif\\n}\\n\"","module.exports = \"#version 300 es\\n\\nprecision highp float;\\nlayout(location = 0) in vec2 aPos;\\n\\nout vec2 uv;\\n\\nuniform mat4 u_MVP;\\n\\nvoid main() {\\n  gl_Position = vec4(aPos, .0f, 1.0f);\\n  vec4 uv_out =  gl_Position * inverse(u_MVP);\\n  uv = uv_out.xy;\\n}\\n\"","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","interface Uniform {\n  type: string\n  name: string\n  uniform: WebGLUniformLocation | null\n}\n\nexport default class Shader {\n  gl: WebGL2RenderingContext\n  uniforms: Uniform[] = []\n  positionLocation: GLint | null = null\n  program: WebGLProgram | null = null\n\n  constructor(gl: WebGL2RenderingContext) {\n    this.gl = gl\n  }\n\n  createProgram(vertexSource: string, fragmentSource: string): void {\n    const gl = this.gl\n    const vertShader = gl.createShader(gl.VERTEX_SHADER)\n    const fragShader = gl.createShader(gl.FRAGMENT_SHADER)\n\n    const vertSrc = gl.shaderSource(vertShader, vertexSource)\n    const fragSrc = gl.shaderSource(fragShader, fragmentSource)\n\n    gl.compileShader(vertShader, vertSrc)\n    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {\n      alert('Error compiling vertex shader')\n      console.log(gl.getShaderInfoLog(vertShader))\n    }\n\n    gl.compileShader(fragShader, fragSrc)\n    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {\n      alert('Error compiling fragment shader')\n      console.log(gl.getShaderInfoLog(fragShader))\n    }\n\n    const program = gl.createProgram()\n    gl.attachShader(program, vertShader)\n    gl.attachShader(program, fragShader)\n    gl.linkProgram(program)\n\n    gl.validateProgram(program)\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n      console.log('Error validating program ', gl.getProgramInfoLog(program))\n      return\n    }\n    this.program = program\n  }\n\n  useProgram(): void {\n    this.gl.useProgram(this.program)\n  }\n\n  addUniform(name, type): void {\n    const uniform = this.gl.getUniformLocation(this.program, name)\n    const u = {\n      name,\n      type,\n      uniform,\n    }\n    this.uniforms.push(u)\n  }\n\n  setUniform(name: string, ...args): void {\n    const u = this.uniforms.find((u) => u.name === name)\n    if (u) {\n      switch (u.type) {\n        case '4fv':\n          this.gl.uniformMatrix4fv(u.uniform, false, args[0])\n          return\n        case '1f':\n          this.gl.uniform1f(u.uniform, args[0])\n          return\n        case '2f':\n          this.gl.uniform2f(u.uniform, args[0], args[1])\n          return\n        case '4f':\n          this.gl.uniform4f(u.uniform, args[0], args[1], args[2], args[3])\n          return\n        case '1i':\n          this.gl.uniform1i(u.uniform, args[0])\n          return\n      }\n    }\n  }\n\n  setPositions(name): void {\n    this.positionLocation = this.gl.getAttribLocation(this.program, name)\n    this.gl.enableVertexAttribArray(this.positionLocation)\n    this.gl.vertexAttribPointer(\n      this.positionLocation,\n      2,\n      this.gl.FLOAT,\n      false,\n      0,\n      0\n    )\n  }\n}\n","let mouseDown\nlet mouseXprev = 0\nlet mouseYprev = 0\nlet mouseX = 0\nlet mouseY = 0\nlet speedX = 0\nlet speedY = 0\n\nconst handleMouseDown = function (e: MouseEvent) {\n  mouseDown = true\n  mouseXprev = e.screenX\n  mouseYprev = e.screenY\n}\n\nconst handleMouseUp = function () {\n  mouseDown = false\n}\n\nconst handleMouseMove = function (e: MouseEvent) {\n  if (mouseDown) {\n    const speedFactor = 0.01\n\n    speedX += (e.screenX - mouseXprev) * speedFactor\n    speedY += (e.screenY - mouseYprev) * speedFactor\n\n    mouseXprev = e.screenX\n    mouseYprev = e.screenY\n  }\n}\n\nconst updateSpeed = function (speed: number) {\n  const dampeningFactor = 0.01\n  if (Math.abs(speed) > 0.1) {\n    return (speed *= 1 - dampeningFactor)\n  }\n  return 0\n}\n\nconst handleMouse = function () {\n  if (!mouseDown) {\n    speedX = updateSpeed(speedX)\n    speedY = updateSpeed(speedY)\n  }\n\n  mouseX += speedX\n  mouseY += speedY\n\n  if (mouseX < -2000) mouseX = -2000\n  if (mouseX > 2000) mouseX = 2000\n\n  if (mouseY < -2000) mouseY = -2000\n  if (mouseY > 2000) mouseY = 2000\n}\n\nexport const getMouseControl = function (): [number, number] {\n  return [mouseX, mouseY]\n}\n\nexport const init = function (): void {\n  window.addEventListener('mousemove', handleMouseMove)\n  window.addEventListener('mousedown', handleMouseDown)\n  window.addEventListener('mouseup', handleMouseUp)\n}\n\nexport const animate = function (): void {\n  handleMouse()\n  requestAnimationFrame(animate)\n}\n","import Shader from 'ts/webgl/shader'\n\nimport nebulaVertexShaderSource from 'shaders/nebula.vert'\nimport nebulaFragmentShaderSource from 'shaders/nebula.frag'\n\nimport {\n  init as orbitControlInit,\n  animate as orbitControlAnimate,\n  getMouseControl,\n} from 'ts/components/orbit-control'\n\nlet canvas: HTMLCanvasElement\nlet rootElement: HTMLDivElement\nlet gl: WebGL2RenderingContext = null\nlet width = 0\nlet height = 0\nlet nebulaShader: Shader\nlet proj\n\nconst calculateMVP = function () {\n  const left = -width / height\n  const right = width / height\n\n  const bottom = -1.0\n  const top = 1.0\n\n  const near = -1.0\n  const far = 1.0\n\n  // prettier-ignore\n  proj = [\n    2 / (right - left),                   0,                 0,  -(right + left) / (right - left),\n                     0,  2 / (top - bottom),                 0,  -(top + bottom) / (top - bottom),\n                     0,                   0,  2 / (far - near),      -(far + near) / (far - near),\n                     0,                   0,                 0,                                 1,\n  ];\n}\n\nconst drawImage = function (): void {\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n  nebulaShader.useProgram()\n  nebulaShader.setUniform('u_MVP', proj)\n  const [mouseX, mouseY] = getMouseControl()\n  nebulaShader.setUniform('u_mouseX', mouseX)\n  nebulaShader.setUniform('u_mouseY', mouseY)\n  gl.clearColor(0.0, 0.0, 0.0, 1.0)\n  gl.clear(gl.COLOR_BUFFER_BIT)\n  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)\n}\n\nconst setCanvasSize = function (): void {\n  width = rootElement.clientWidth\n  height = rootElement.clientHeight\n  canvas.width = width\n  canvas.height = height\n  canvas.style.width = `${width}px`\n  canvas.style.height = `${height}px`\n  gl.viewport(0, 0, width, height)\n}\n\nexport const animate = function () {\n  calculateMVP()\n  drawImage()\n  requestAnimationFrame(animate)\n}\n\nexport const init = function (root) {\n  rootElement = root\n  canvas = document.createElement(`canvas`)\n  root.appendChild(canvas)\n  canvas.id = 'canvas'\n\n  gl = canvas.getContext('webgl2')\n\n  setCanvasSize()\n\n  window.addEventListener('resize', setCanvasSize)\n  orbitControlInit()\n  orbitControlAnimate()\n\n  nebulaShader = new Shader(gl)\n  nebulaShader.createProgram(\n    nebulaVertexShaderSource,\n    nebulaFragmentShaderSource\n  )\n\n  const vertexBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\n\n  // prettier-ignore\n  const positions = [\n      -1.0,  -1.0,\n      1.0,  -1.0,\n      1.0,  1.0,\n      -1.0,  1.0\n    ];\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)\n\n  const indexBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)\n\n  // prettier-ignore\n  const indices = [\n      0, 1, 2,\n      2, 3, 0\n    ];\n\n  gl.bufferData(\n    gl.ELEMENT_ARRAY_BUFFER,\n    new Uint16Array(indices),\n    gl.STATIC_DRAW\n  )\n\n  nebulaShader.useProgram()\n  nebulaShader.setPositions('aPos')\n  nebulaShader.addUniform('u_MVP', '4fv')\n  nebulaShader.addUniform('u_mouseX', '1f')\n  nebulaShader.addUniform('u_mouseY', '1f')\n\n  // Create and bind the framebuffer\n  // frameBuffer = gl.createFramebuffer()\n  // gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n}\n","import { init, animate } from 'ts/components/nebula'\n\nimport 'css/config.scss'\nimport 'css/null.scss'\nimport 'css/global.scss'\n\nlet canvasContainer: HTMLDivElement\n\nwindow.onload = () => {\n  canvasContainer = document.getElementById('canvas-container')\n\n  init(canvasContainer)\n  animate()\n}\n"],"names":["module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Shader","constructor","gl","uniforms","positionLocation","program","this","createProgram","vertexSource","fragmentSource","vertShader","createShader","VERTEX_SHADER","fragShader","FRAGMENT_SHADER","vertSrc","shaderSource","fragSrc","compileShader","getShaderParameter","COMPILE_STATUS","alert","console","log","getShaderInfoLog","attachShader","linkProgram","validateProgram","getProgramParameter","VALIDATE_STATUS","getProgramInfoLog","useProgram","addUniform","name","type","u","uniform","getUniformLocation","push","setUniform","args","find","uniformMatrix4fv","uniform1f","uniform2f","uniform4f","uniform1i","setPositions","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","mouseDown","mouseXprev","mouseYprev","mouseX","mouseY","speedX","speedY","handleMouseDown","e","screenX","screenY","handleMouseUp","handleMouseMove","speedFactor","updateSpeed","speed","Math","abs","getMouseControl","animate","requestAnimationFrame","canvas","rootElement","nebulaShader","proj","width","height","setCanvasSize","clientWidth","clientHeight","style","viewport","left","right","calculateMVP","bindFramebuffer","FRAMEBUFFER","clearColor","clear","COLOR_BUFFER_BIT","drawElements","TRIANGLES","UNSIGNED_SHORT","drawImage","canvasContainer","window","onload","document","getElementById","root","createElement","appendChild","id","getContext","addEventListener","orbitControlAnimate","nebulaVertexShaderSource","nebulaFragmentShaderSource","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","indexBuffer","ELEMENT_ARRAY_BUFFER","Uint16Array","init"],"sourceRoot":""}