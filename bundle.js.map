{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://mfecane.github.io/./src/shaders/nebula.frag","webpack://mfecane.github.io/./src/shaders/nebula.vert","webpack://mfecane.github.io/webpack/bootstrap","webpack://mfecane.github.io/webpack/runtime/compat get default export","webpack://mfecane.github.io/webpack/runtime/define property getters","webpack://mfecane.github.io/webpack/runtime/hasOwnProperty shorthand","webpack://mfecane.github.io/./src/ts/webgl/shader.ts","webpack://mfecane.github.io/./src/ts/components/orbit-control.ts","webpack://mfecane.github.io/./src/ts/lib/easing-functions.ts","webpack://mfecane.github.io/./src/ts/components/nebula.ts","webpack://mfecane.github.io/./src/ts/index.ts"],"sourcesContent":["module.exports = \"#version 300 es\\n\\nprecision highp float;\\n\\nout vec4 FragColor;\\nin vec2 uv;\\n\\n// source https://www.shadertoy.com/view/MsVXWW\\n\\nuniform float u_time;\\nuniform float u_mouseX;\\nuniform float u_mouseY;\\nuniform float u_scrollValue;\\n\\n#define ROTATION\\n//#define MOUSE_CAMERA_CONTROL\\n\\n#define DITHERING\\n#define BACKGROUND\\n\\n//#define TONEMAPPING\\n\\n//-------------------\\n#define PI 3.14159265358979323846\\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\\n\\nvec3 cartesianToPolar (vec3 v)\\n{\\n\\tvec3 polar;\\n  float HALF_PI = PI / 2.0;\\n\\tpolar[0] = length(v);\\n\\n\\tif (v[2] > 0.0f) {\\n\\t\\tpolar[1] = atan(sqrt (v[0] * v[0]+ v[1] * v[1]) / v[2]);\\n\\t}\\n\\telse if (v[2] < 0.0f) {\\n\\t\\tpolar[1] = atan(sqrt(v[0] * v[0]+ v[1] * v[1]) / v[2]) + PI;\\n\\t}\\n\\telse {\\n\\t\\tpolar[1] = PI * 0.5f;\\n\\t}\\n\\tpolar[ 1 ] -= HALF_PI;\\n\\tif (v[0] != 0.0f) {\\n        polar[2] = clamp(atan (v[1], v[0]), -PI, PI);\\n    }\\n\\telse if (v[1] > 0.0) {\\n\\t\\tpolar[2] = PI * 0.5f;\\n\\t}\\n\\telse {\\n\\t\\tpolar[2] = -PI * 0.5;\\n\\t}\\n\\treturn polar;\\n}\\n\\n// iq's noise\\nfloat noise( in vec3 x )\\n{\\n  vec3 p = floor(x);\\n  vec3 f = fract(x);\\n\\tf = f * f * (3.0 - 2.0 * f);\\n\\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\\n\\treturn 1.0 - 0.82 * mix(0.0, 0.0, f.z);\\n}\\n\\nfloat rand(vec2 co)\\n{\\n\\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\n//=====================================\\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\\n//--------------------------------------------------------------\\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\\n// It should work the same on all computers since it's not based on a hash function like some other noises.\\n// It can be much faster than other noise functions if you're ok with some repetition.\\nconst float nudge = 0.739513;\\t// size of perpendicular vector\\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\\t// pythagorean theorem on that perpendicular to maintain scale\\nfloat SpiralNoiseC(vec3 p)\\n{\\n  float n = 0.0;\\t// noise amount\\n  float iter = 1.0;\\n  for (int i = 0; i < 8; i++)\\n  {\\n    // add sin and cos scaled inverse with the frequency\\n    n += -abs(sin(p.y * iter) + cos(p.x * iter)) / iter;\\t// abs for a ridged look\\n    // rotate by adding perpendicular and scaling down\\n    p.xy += vec2(p.y, -p.x) * nudge;\\n    p.xy *= normalizer;\\n    // rotate on other axis\\n    p.xz += vec2(p.z, -p.x) * nudge;\\n    p.xz *= normalizer;\\n    // increase the frequency\\n    iter *= 1.733733;\\n  }\\n  return n;\\n}\\n\\nfloat SpiralNoise3D(vec3 p)\\n{\\n  float n = 0.0;\\n  float iter = 1.0;\\n  for (int i = 0; i < 5; i++)\\n  {\\n    n += (sin(p.y * iter) + cos(p.x * iter)) / iter;\\n    p.xz += vec2(p.z, -p.x) * nudge;\\n    p.xz *= normalizer;\\n    iter *= 1.33733;\\n  }\\n  return n;\\n}\\n\\nfloat NebulaNoise(vec3 p)\\n{\\n  float final = p.y + 4.5;\\n  final -= SpiralNoiseC(p.xyz);   // mid-range noise\\n  final += SpiralNoiseC(p.zxy * 0.5123 + 100.0) * 4.0;   // large scale features\\n  final -= SpiralNoise3D(p);   // more large scale features, but 3d\\n\\n  return final;\\n}\\n\\nfloat map(vec3 p)\\n{\\n  float NebNoise = abs(NebulaNoise(p / 0.5) * 0.5);\\n  return NebNoise + 0.03;\\n}\\n//--------------------------------------------------------------\\n\\n// assign color to the media\\nvec3 computeColor( float density, float radius )\\n{\\n\\t// color based on density alone, gives impression of occlusion within\\n\\t// the media\\n\\tvec3 result = mix(vec3(1.0, 0.9, 0.8), vec3(0.4, 0.15, 0.1), density);\\n\\n\\t// color added to the media\\n\\tvec3 colCenter = 7.0 * vec3(0.8, 1.0, 1.0);\\n\\tvec3 colEdge = 1.5 * vec3(0.48, 0.53, 0.5);\\n\\tresult *= mix(colCenter, colEdge, min((radius + 0.05) / 0.9, 1.15));\\n\\n\\treturn result;\\n}\\n\\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\\n{\\n\\tfloat b = dot(dir, org);\\n\\tfloat c = dot(org, org) - 8.;\\n\\tfloat delta = b * b - c;\\n\\tif( delta < 0.0)\\n\\t\\treturn false;\\n\\tfloat deltasqrt = sqrt(delta);\\n\\tnear = -b - deltasqrt;\\n\\tfar = -b + deltasqrt;\\n\\treturn far > 0.0;\\n}\\n\\n// Applies the filmic curve from John Hable's presentation\\n// More details at : http://filmicgames.com/archives/75\\nvec3 ToneMapFilmicALU(vec3 _color)\\n{\\n\\t_color = max(vec3(0), _color - vec3(0.004));\\n\\t_color = (_color * (6.2 * _color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\\n\\treturn _color;\\n}\\n\\nfloat easeInOutQuad(float x) {\\n  float two = 2.0;\\n  return x < 0.5 ?\\n    two * x * x :\\n    1.0 - (-two * x + two) * (-two * x + two) / two;\\n}\\n\\nfloat Noise21(vec2 p){\\n  p = fract(p * vec2(123.344314, 234.542341));\\n  p += dot(p, p + 23.4123);\\n  return fract(p.x * p.y);\\n}\\n\\nfloat stars(vec2 p, float seed) {\\n  p *= 5.0 * seed;\\n  float n = Noise21(floor(p));\\n\\n  p = fract(p);\\n  vec2 shift = vec2(n - 0.5, fract(n * 10.0));\\n  float d = length(p - shift);\\n  float m = smoothstep(0.02 * n * sqrt(seed), 0.0, d) * n;\\n  return m;\\n}\\n\\nvec3 polarNormalize (vec3 polar) {\\n  return vec3(polar.x, asin(polar.y / PI) * PI, polar.z);\\n}\\n\\nvoid main()\\n{\\n  vec3 debugColor;\\n  // float seed = 1.0;\\n  //   const float KEY_1 = 49.5/256.0;\\n\\t// const float KEY_2 = 50.5/256.0;\\n\\t// const float KEY_3 = 51.5/256.0;\\n  float key = 0.0;\\n  // key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\\n  // key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\\n  // key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\\n\\n\\t// ro: ray origin\\n\\t// rd: direction of the ray\\n\\t// vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\\n\\tvec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0));\\n\\tvec3 rayOrigin = vec3(0.0, 0.0, -u_scrollValue);\\n\\n  const float mouseFactor = 0.002;\\n  R(rayDirection.yz, -u_mouseY * mouseFactor * PI * 2.0);\\n  R(rayDirection.xz, u_mouseX * mouseFactor * PI * 2.0);\\n  R(rayOrigin.yz, -u_mouseY * mouseFactor * PI * 2.0);\\n  R(rayOrigin.xz, u_mouseX * mouseFactor * PI * 2.0);\\n\\n  // DITHERING\\n\\tvec2 seed = fract(uv * 2.0) / 2.0 + sin(u_time / 2.0);\\n\\n\\t// ld, totalDensity: local, total density\\n\\t// w: weighting factor\\n\\tfloat localDensity = 0.0, totalDensity = 0.0, w = 0.0;\\n\\n\\t// t: length of the ray\\n\\t// d: distance function\\n\\tfloat d = 1.0, t = 0.0;\\n\\n  const float h = 0.1;\\n\\n\\tvec4 sum = vec4(0.0);\\n\\n  float min_dist = 0.0, max_dist = 0.0;\\n\\n\\n  // march ray to the sphere\\n  if (RaySphereIntersect(rayOrigin, rayDirection, min_dist, max_dist))\\n  {\\n\\t  t = min_dist * step(t, min_dist);\\n\\n    // raymarch loop\\n    for (int i = 0; i < 56; i++)\\n    {\\n      vec3 pos = rayOrigin + t * rayDirection;\\n\\n      if (totalDensity > 0.9 || d < 0.1 * t || t > 10.0 || sum.a > 0.99 || t > max_dist) break;\\n\\n      // evaluate distance function\\n      float d = map(pos);\\n\\n      // change this string to control density\\n      d = max(d, 0.07);\\n\\n      // point light calculations\\n      vec3 ldst = vec3(0.0) - pos;\\n      float lDist = max(length(ldst), 0.001);\\n\\n      // star in center\\n      vec3 lightColor = vec3(1.0, 0.5, 0.25);\\n      sum.rgb += (lightColor / (lDist * lDist) / 30.0); // star itself and bloom around the light\\n\\n      if (d < h)\\n      {\\n        // compute local density\\n        localDensity = h - d;\\n\\n              // compute weighting factor\\n        w = (1.0 - totalDensity) * localDensity;\\n\\n        // accumulate density\\n        totalDensity += w + 1./200.;\\n\\n        vec4 col = vec4( computeColor(totalDensity, lDist), totalDensity );\\n\\n        // uniform scale density\\n        col.a *= 0.185;\\n        // colour by alpha\\n        col.rgb *= col.a;\\n        // alpha blend in contribution\\n        sum = sum + col*(1.0 - sum.a);\\n\\n      }\\n\\n      totalDensity += 1./70.;\\n\\n      // enforce minimum stepsize\\n      d = max(d, 0.04);\\n\\n      // DITHERING\\n      d = abs(d) * (0.8 + 0.2 * rand(seed * vec2(i)));\\n\\n      // trying to optimize step size near the camera and near the light source\\n      t += max(d * 0.1 * max(min(length(ldst), length(rayOrigin)), 1.0), 0.02);\\n    }\\n    debugColor = vec3(sum);\\n\\n    // simple scattering\\n\\t  sum *= 1.0 / exp( localDensity * 0.2 ) * 0.6;\\n   \\tsum = clamp( sum, 0.0, 1.0 );\\n    sum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\\n\\t}\\n\\n  // BACKGROUND\\n  // if (totalDensity < 0.8)\\n  // {\\n  //   vec3 stars = vec3(noise(rayDirection * 500.0) * 0.5 + 0.5);\\n  //   vec3 starbg = vec3(0.0);\\n  //   starbg = mix(starbg, vec3(0.8, 0.9, 1.0), smoothstep(0.99, 1.0, stars) * clamp(dot(vec3(0.0), rayDirection) + 0.75, 0.0, 1.0));\\n  //   starbg = clamp(starbg, 0.0, 1.0);\\n  //   sum.xyz += starbg;\\n  // }\\n  debugColor = ToneMapFilmicALU(sum.xyz * 2.2);\\n\\n  vec3 polar1 = cartesianToPolar(rayDirection.xzy);\\n  vec3 polar2 = cartesianToPolar(rayDirection.xyz);\\n  R(rayDirection.yz, PI / 2.0);\\n  vec3 polar3 = cartesianToPolar(rayDirection.xyz);\\n  // TODO ::: rotate polar systems\\n  debugColor += stars(polarNormalize(polar1).yz, 5.43141);\\n  debugColor += stars(polarNormalize(polar2).yz, 6.4324);\\n  debugColor += stars(polarNormalize(polar3).yz, 7.11231);\\n\\n  // FragColor = vec4(sum.xyz, 1.0);\\n  // TONEMAPPING\\n  FragColor = vec4(vec3(debugColor), 1.0);\\n}\\n\"","module.exports = \"#version 300 es\\n\\nprecision highp float;\\nlayout(location = 0) in vec2 aPos;\\n\\nout vec2 uv;\\n\\nuniform mat4 u_MVP;\\n\\nvoid main() {\\n  gl_Position = vec4(aPos, .0f, 1.0f);\\n  vec4 uv_out =  gl_Position * inverse(u_MVP);\\n  uv = uv_out.xy;\\n}\\n\"","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","interface Uniform {\n  type: string\n  name: string\n  uniform: WebGLUniformLocation | null\n}\n\nexport default class Shader {\n  gl: WebGL2RenderingContext\n  uniforms: Uniform[] = []\n  positionLocation: GLint | null = null\n  program: WebGLProgram | null = null\n\n  constructor(gl: WebGL2RenderingContext) {\n    this.gl = gl\n  }\n\n  createProgram(vertexSource: string, fragmentSource: string): void {\n    const gl = this.gl\n    const vertShader = gl.createShader(gl.VERTEX_SHADER)\n    const fragShader = gl.createShader(gl.FRAGMENT_SHADER)\n\n    const vertSrc = gl.shaderSource(vertShader, vertexSource)\n    const fragSrc = gl.shaderSource(fragShader, fragmentSource)\n\n    gl.compileShader(vertShader, vertSrc)\n    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {\n      console.error('Error compiling vertex shader')\n      console.log(gl.getShaderInfoLog(vertShader))\n    }\n\n    gl.compileShader(fragShader, fragSrc)\n    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {\n      console.error('Error compiling fragment shader')\n      console.log(gl.getShaderInfoLog(fragShader))\n    }\n\n    const program = gl.createProgram()\n    gl.attachShader(program, vertShader)\n    gl.attachShader(program, fragShader)\n    gl.linkProgram(program)\n\n    gl.validateProgram(program)\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n      console.log('Error validating program ', gl.getProgramInfoLog(program))\n      return\n    }\n    this.program = program\n  }\n\n  useProgram(): void {\n    this.gl.useProgram(this.program)\n  }\n\n  addUniform(name, type): void {\n    const uniform = this.gl.getUniformLocation(this.program, name)\n    const u = {\n      name,\n      type,\n      uniform,\n    }\n    this.uniforms.push(u)\n  }\n\n  setUniform(name: string, ...args): void {\n    const u = this.uniforms.find((u) => u.name === name)\n    if (u) {\n      switch (u.type) {\n        case '4fv':\n          this.gl.uniformMatrix4fv(u.uniform, false, args[0])\n          return\n        case '1f':\n          this.gl.uniform1f(u.uniform, args[0])\n          return\n        case '2f':\n          this.gl.uniform2f(u.uniform, args[0], args[1])\n          return\n        case '4f':\n          this.gl.uniform4f(u.uniform, args[0], args[1], args[2], args[3])\n          return\n        case '1i':\n          this.gl.uniform1i(u.uniform, args[0])\n          return\n      }\n    }\n  }\n\n  setPositions(name): void {\n    this.positionLocation = this.gl.getAttribLocation(this.program, name)\n    this.gl.enableVertexAttribArray(this.positionLocation)\n    this.gl.vertexAttribPointer(\n      this.positionLocation,\n      2,\n      this.gl.FLOAT,\n      false,\n      0,\n      0\n    )\n  }\n}\n","import { easeOutCubic } from 'ts/lib/easing-functions'\n\nlet mouseDown\nlet mouseXprev = 0\nlet mouseYprev = 0\nlet mouseX = 0\nlet mouseY = 0\nlet speedX = 0\nlet speedY = 0\n\nlet lastScrollValue = 0\nlet scrollValue = 1\nlet scrollValueMin = 0.5\nlet scrollValueMax = 4\nlet scrollStep = 0.25\nlet targetScrollValue = 1\nlet scrollTime = 0\n// TODO ::: use time not frames\nlet scrollMaxTime = 100\n\nconst handleMouseDown = function (e: MouseEvent) {\n  mouseDown = true\n  mouseXprev = e.screenX\n  mouseYprev = e.screenY\n}\n\nconst handleMouseUp = function () {\n  mouseDown = false\n}\n\nconst handleMouseMove = function (e: MouseEvent) {\n  if (mouseDown) {\n    const speedFactor = 0.01\n\n    speedX += (e.screenX - mouseXprev) * speedFactor\n    speedY += (e.screenY - mouseYprev) * speedFactor\n\n    mouseXprev = e.screenX\n    mouseYprev = e.screenY\n  }\n}\n\nconst updateSpeed = function (speed: number) {\n  const dampeningFactor = 0.01\n  if (Math.abs(speed) > 0.1) {\n    return (speed *= 1 - dampeningFactor)\n  }\n  return 0\n}\n\nconst handleMouse = function () {\n  if (!mouseDown) {\n    speedX = updateSpeed(speedX)\n    speedY = updateSpeed(speedY)\n  }\n\n  mouseX += speedX\n  mouseY += speedY\n\n  if (mouseX < -2000) mouseX = -2000\n  if (mouseX > 2000) mouseX = 2000\n\n  if (mouseY < -2000) mouseY = -2000\n  if (mouseY > 2000) mouseY = 2000\n}\n\nconst handleScroll = function (e) {\n  const value = e.deltaY\n  if (value > 0 && targetScrollValue < scrollValueMax) {\n    targetScrollValue += scrollStep\n  } else if (value < 0 && targetScrollValue > scrollValueMin) {\n    targetScrollValue -= scrollStep\n  }\n\n  lastScrollValue = scrollValue\n  scrollTime = 0\n}\n\nconst updateScroll = function () {\n  if (\n    Math.abs(lastScrollValue - targetScrollValue) < 0.1 ||\n    scrollTime > scrollMaxTime\n  ) {\n    scrollValue = targetScrollValue\n    return\n  }\n\n  const val = easeOutCubic(scrollTime / scrollMaxTime)\n  scrollValue = lastScrollValue + val * (targetScrollValue - lastScrollValue)\n  scrollTime += 1\n}\n\nexport const getMouseControl = function (): [number, number, number] {\n  return [mouseX, mouseY, scrollValue];\n}\nexport const init = function (): void {\n  window.addEventListener('mousemove', handleMouseMove)\n  window.addEventListener('mousedown', handleMouseDown)\n  window.addEventListener('mouseup', handleMouseUp)\n  document.addEventListener('wheel', handleScroll)\n}\n\nexport const animate = function (): void {\n  handleMouse()\n  updateScroll()\n  requestAnimationFrame(animate)\n}\n","export function easeInOutQuint(x: number): number {\r\n  return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2\r\n}\r\n\r\nexport function easeOutCubic(x: number): number {\r\n  return 1 - Math.pow(1 - x, 3)\r\n}\r\n\r\nexport function easeInCubic(x: number): number {\r\n  return Math.pow(x, 3)\r\n}\r\n\r\nexport function easeOutSquare(x: number): number {\r\n  return 1 - Math.pow(1 - x, 2)\r\n}\r\n\r\nexport function easeInSquare(x: number): number {\r\n  return Math.pow(x, 2)\r\n}\r\n\r\nexport function easeInOutQuad(x: number): number {\r\n  return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2\r\n}\r\n\r\nexport function easeOutBack(x: number): number {\r\n  const c1 = 1.70158\r\n  const c3 = c1 + 1\r\n\r\n  return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2)\r\n}\r\n\r\nexport function easeInOutCubic(x: number): number {\r\n  return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2\r\n}\r\n","import Shader from 'ts/webgl/shader'\n\nimport nebulaVertexShaderSource from 'shaders/nebula.vert'\nimport nebulaFragmentShaderSource from 'shaders/nebula.frag'\n\nimport {\n  init as orbitControlInit,\n  animate as orbitControlAnimate,\n  getMouseControl,\n} from 'ts/components/orbit-control'\n\nlet canvas: HTMLCanvasElement\nlet rootElement: HTMLDivElement\nlet gl: WebGL2RenderingContext = null\nlet width = 0\nlet height = 0\nlet nebulaShader: Shader\nlet proj\nlet startTime = Date.now()\nlet time = startTime\n\nconst calculateMVP = function () {\n  const left = -width / height\n  const right = width / height\n\n  const bottom = -1.0\n  const top = 1.0\n\n  const near = -1.0\n  const far = 1.0\n\n  // prettier-ignore\n  proj = [\n    2 / (right - left),                   0,                 0,  -(right + left) / (right - left),\n                     0,  2 / (top - bottom),                 0,  -(top + bottom) / (top - bottom),\n                     0,                   0,  2 / (far - near),      -(far + near) / (far - near),\n                     0,                   0,                 0,                                 1,\n  ];\n}\n\nconst drawImage = function (): void {\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n  nebulaShader.useProgram()\n  nebulaShader.setUniform('u_MVP', proj)\n  const [mouseX, mouseY, scrollValue] = getMouseControl()\n  time = (Date.now() - startTime) / 1000\n  // console.log('time', time)\n  nebulaShader.setUniform('u_time', time)\n  nebulaShader.setUniform('u_mouseX', mouseX)\n  nebulaShader.setUniform('u_mouseY', mouseY)\n  nebulaShader.setUniform('u_scrollValue', scrollValue)\n  gl.clearColor(0.0, 0.0, 0.0, 1.0)\n  gl.clear(gl.COLOR_BUFFER_BIT)\n  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)\n}\n\nconst setCanvasSize = function (): void {\n  width = rootElement.clientWidth\n  height = rootElement.clientHeight\n  canvas.width = width\n  canvas.height = height\n  canvas.style.width = `${width}px`\n  canvas.style.height = `${height}px`\n  gl.viewport(0, 0, width, height)\n}\n\nexport const animate = function () {\n  calculateMVP()\n  drawImage()\n  requestAnimationFrame(animate)\n}\n\nexport const init = function (root) {\n  rootElement = root\n  canvas = document.createElement(`canvas`)\n  root.appendChild(canvas)\n  canvas.id = 'canvas'\n\n  gl = canvas.getContext('webgl2')\n\n  setCanvasSize()\n\n  window.addEventListener('resize', setCanvasSize)\n  orbitControlInit()\n  orbitControlAnimate()\n\n  nebulaShader = new Shader(gl)\n  nebulaShader.createProgram(\n    nebulaVertexShaderSource,\n    nebulaFragmentShaderSource\n  )\n\n  const vertexBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\n\n  // prettier-ignore\n  const positions = [\n      -1.0,  -1.0,\n      1.0,  -1.0,\n      1.0,  1.0,\n      -1.0,  1.0\n    ];\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)\n\n  const indexBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)\n\n  // prettier-ignore\n  const indices = [\n      0, 1, 2,\n      2, 3, 0\n    ];\n\n  gl.bufferData(\n    gl.ELEMENT_ARRAY_BUFFER,\n    new Uint16Array(indices),\n    gl.STATIC_DRAW\n  )\n\n  nebulaShader.useProgram()\n  nebulaShader.setPositions('aPos')\n  nebulaShader.addUniform('u_MVP', '4fv')\n  nebulaShader.addUniform('u_time', '1f')\n  nebulaShader.addUniform('u_mouseX', '1f')\n  nebulaShader.addUniform('u_mouseY', '1f')\n  nebulaShader.addUniform('u_scrollValue', '1f')\n\n  // Create and bind the framebuffer\n  // frameBuffer = gl.createFramebuffer()\n  // gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n}\n","import { init, animate } from 'ts/components/nebula'\n\nimport 'css/config.scss'\nimport 'css/null.scss'\nimport 'css/global.scss'\n\nlet canvasContainer: HTMLDivElement\n\nwindow.onload = () => {\n  canvasContainer = document.getElementById('canvas-container')\n\n  init(canvasContainer)\n  animate()\n}\n"],"names":["module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Shader","constructor","gl","uniforms","positionLocation","program","this","createProgram","vertexSource","fragmentSource","vertShader","createShader","VERTEX_SHADER","fragShader","FRAGMENT_SHADER","vertSrc","shaderSource","fragSrc","compileShader","getShaderParameter","COMPILE_STATUS","console","error","log","getShaderInfoLog","attachShader","linkProgram","validateProgram","getProgramParameter","VALIDATE_STATUS","getProgramInfoLog","useProgram","addUniform","name","type","u","uniform","getUniformLocation","push","setUniform","args","find","uniformMatrix4fv","uniform1f","uniform2f","uniform4f","uniform1i","setPositions","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","mouseDown","mouseXprev","mouseYprev","mouseX","mouseY","speedX","speedY","lastScrollValue","scrollValue","targetScrollValue","scrollTime","handleMouseDown","e","screenX","screenY","handleMouseUp","handleMouseMove","speedFactor","updateSpeed","speed","Math","abs","handleScroll","value","deltaY","getMouseControl","animate","val","x","pow","updateScroll","requestAnimationFrame","canvas","rootElement","nebulaShader","proj","width","height","startTime","Date","now","time","setCanvasSize","clientWidth","clientHeight","style","viewport","left","right","calculateMVP","bindFramebuffer","FRAMEBUFFER","clearColor","clear","COLOR_BUFFER_BIT","drawElements","TRIANGLES","UNSIGNED_SHORT","drawImage","canvasContainer","window","onload","document","getElementById","root","createElement","appendChild","id","getContext","addEventListener","orbitControlAnimate","nebulaVertexShaderSource","nebulaFragmentShaderSource","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","indexBuffer","ELEMENT_ARRAY_BUFFER","Uint16Array","init"],"sourceRoot":""}